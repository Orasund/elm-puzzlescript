[{"name":"PuzzleScript.Rule","comment":" Module for constructing PuzzleScript rules\n\n\n## Transition\n\n@docs into, spawn, kill, constant\n\n\n## Moving Transition\n\n@docs Direction, whileMoving, thenMoving, thenStopping\n\n\n## Pattern\n\n@docs Pattern, layered, touching, onLine, multiLine\n\n\n## Rule\n\n@docs Rule, fromPattern, DirectionalEval, onlyEval, toString\n\n\n## Internal\n\n@docs Transition, Element, Tag, Singleton, Layered, Touching, Line, MultiLine, LayeredOr, TouchingOrLayeredOr, LineOrTouchingOrLayeredOr\n\n","unions":[{"name":"Direction","comment":" Directions\n","args":[],"cases":[["TurningLeft",[]],["TurningRight",[]],["Backwards",[]],["Forwards",[]]]},{"name":"DirectionalEval","comment":" Internal type for restricting the evaluation\n","args":[],"cases":[]},{"name":"Pattern","comment":" Pattern for a PuzzleScript Result.\n\nA rule can be composed of multiple patterns\n\n","args":["a"],"cases":[]},{"name":"Tag","comment":" Internal type.\n","args":["a"],"cases":[]}],"aliases":[{"name":"Element","comment":" Internal type.\n","args":[],"type":"{ object : String.String, direction : Maybe.Maybe PuzzleScript.Rule.Direction }"},{"name":"Layered","comment":" Internal type representing a layered pattern\n","args":[],"type":"PuzzleScript.Rule.Tag { noTouching : (), noLine : (), noMultiLine : () }"},{"name":"LayeredOr","comment":" Internal type representing either a `Layered` or a `singleton`\n","args":["singleton"],"type":"PuzzleScript.Rule.Tag { singleton | noTouching : () }"},{"name":"Line","comment":" Internal type representing a line pattern\n","args":[],"type":"PuzzleScript.Rule.Tag { noMultiLine : () }"},{"name":"LineOrTouchingOrLayeredOr","comment":" Internal type representing either a `Line`, `Touching`, `Layered` or a `singleton`\n","args":["singleton"],"type":"PuzzleScript.Rule.Tag { singleton | noMultiLine : () }"},{"name":"MultiLine","comment":" Internal type representing a multiline pattern\n","args":[],"type":"PuzzleScript.Rule.Tag { isMultiline : () }"},{"name":"Rule","comment":" PuzzleScript Rule.\n\nUse this module to construct a rule.\n\n","args":[],"type":"{ pattern : List.List (List.List (List.List (List.List PuzzleScript.Rule.Transition))), lateEvaluation : Basics.Bool, directionalEvaluation : Maybe.Maybe PuzzleScript.Rule.DirectionalEval }"},{"name":"Singleton","comment":" Internal type representing a singleton pattern\n","args":[],"type":"PuzzleScript.Rule.Tag { noLayers : (), noTouching : (), noLine : (), noMultiLine : () }"},{"name":"Touching","comment":" Internal type representing a touching pattern\n","args":[],"type":"PuzzleScript.Rule.Tag { noLine : (), noMultiLine : () }"},{"name":"TouchingOrLayeredOr","comment":" Internal type representing either a `Touching`, `Layered` or a `singleton`\n","args":["singleton"],"type":"PuzzleScript.Rule.Tag { singleton | noLine : () }"},{"name":"Transition","comment":" Internal type.\n\nTransition from one object to another.\n\n","args":[],"type":"( Maybe.Maybe PuzzleScript.Rule.Element, Maybe.Maybe PuzzleScript.Rule.Element )"}],"values":[{"name":"constant","comment":" constructs a \"transition\" from a stationary object.\n\nThat object will not move.\n\n    \"player\"\n      |> constant\n      |> fromPattern\n      |> toString\n      --> \"LATE [ player ] -> [ player ]\"\n\n","type":"String.String -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton"},{"name":"fromPattern","comment":" convert any pattern into a rule.\n\n    constant \"player\"\n      |> whileMoving Forwards\n      |> fromPattern\n      |> toString\n      --> \"[ > player ] -> [ > player ]\"\n\n","type":"PuzzleScript.Rule.Pattern pattern -> PuzzleScript.Rule.Rule"},{"name":"into","comment":" constructs a transition.\n\n    \"player\"\n      |> into \"star\"\n      |> fromPattern\n      |> toString\n      --> \"LATE [ player ] -> [ star ]\"\n\n","type":"String.String -> String.String -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton"},{"name":"kill","comment":" constructs a transition into nothing\n\n    \"player\"\n      |> kill\n      |> fromPattern\n      |> toString\n      --> \"LATE [ player ] -> []\"\n\n","type":"String.String -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton"},{"name":"layered","comment":" pattern of touching objects\n\n    [ kill \"player\" , kill \"mine\" ]\n      |> layered\n      |> fromPattern\n      |> toString\n      --> \"LATE [ player mine ] -> []\"\n\n","type":"List.List (PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton) -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Layered"},{"name":"multiLine","comment":" pattern of objects on different lines. These lines do not need to be next to each other.\n\n    [ [ \"player\" |> kill |> whileMoving Forwards\n      , constant \"portal\"\n      ]\n        |> touching\n    , [ constant \"portal\", \"player\" |> spawn ] |> touching\n    ]\n      |> multiLine\n      |> fromPattern\n      |> toString\n      --> \"[ > player | portal ][ portal |  ] -> [  | portal ][ portal | player ]\"\n\n","type":"List.List (PuzzleScript.Rule.Pattern (PuzzleScript.Rule.LineOrTouchingOrLayeredOr singleton)) -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.MultiLine"},{"name":"onLine","comment":" pattern of objects on a straight line\n\n    [ [ \"player\" |> kill |> whileMoving Forwards\n      , constant \"portal\"\n      ]\n        |> touching\n    , touching [ constant \"portal\", \"player\" |> spawn ]\n    ]\n      |> onLine\n      |> fromPattern\n      |> toString\n      --> \"[ > player | portal | ... | portal |  ] -> [  | portal | ... | portal | player ]\"\n\n","type":"List.List (PuzzleScript.Rule.Pattern (PuzzleScript.Rule.TouchingOrLayeredOr singleton)) -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Line"},{"name":"onlyEval","comment":" Restrict the evaluation to a specific set of directions\n","type":"PuzzleScript.Rule.DirectionalEval -> PuzzleScript.Rule.Rule -> PuzzleScript.Rule.Rule"},{"name":"spawn","comment":" constructs a transition from nothing\n\n    \"monster\"\n      |> spawn\n      |> fromPattern\n      |> toString\n      --> \"LATE [] -> [ monster ]\"\n\n","type":"String.String -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton"},{"name":"thenMoving","comment":" transitions into a new movement.\n\n    \"player\"\n    |> constant\n    |> whileMoving Forwards\n    |> thenMoving Backwards\n    |> fromPattern\n    |> toString\n    --> \"[ > player ] -> [ < player ]\"\n\nif there was no movement to begin with, then it will start moving\n\n    \"player\"\n    |> constant\n    |> thenMoving Backwards\n    |> fromPattern\n    |> toString\n    --> \"[ player ] -> [ < player ]\"\n\n","type":"PuzzleScript.Rule.Direction -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton"},{"name":"thenStopping","comment":" stops the movement.\n\n    \"player\"\n    |> constant\n    |> whileMoving Forwards\n    |> thenStopping\n    |> fromPattern\n    |> toString\n    --> \"[ > player ] -> [ player ]\"\n\n","type":"PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton"},{"name":"toString","comment":" converts a rule into a string.\n\n    []\n      |> multiLine\n      |> fromPattern\n      |> toString\n      --> \"LATE [] -> []\"\n\n","type":"PuzzleScript.Rule.Rule -> String.String"},{"name":"touching","comment":" pattern of touching objects\n\n    [ constant \"fire\" , \"tree\" |> into \"fire\" ]\n      |> touching\n      |> fromPattern\n      |> toString\n      --> \"LATE [ fire | tree ] -> [ fire | fire ]\"\n\n","type":"List.List (PuzzleScript.Rule.Pattern (PuzzleScript.Rule.LayeredOr singleton)) -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Touching"},{"name":"whileMoving","comment":" adds a constant movement to a transition\n\n    \"player\"\n    |> constant\n    |> whileMoving Forwards\n    |> fromPattern\n    |> toString\n    --> \"[ > player ] -> [ > player ]\"\n\n","type":"PuzzleScript.Rule.Direction -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton -> PuzzleScript.Rule.Pattern PuzzleScript.Rule.Singleton"}],"binops":[]}]